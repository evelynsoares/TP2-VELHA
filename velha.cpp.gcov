        -:    0:Source:velha.cpp
        -:    0:Graph:velha.gcno
        -:    0:Data:velha.gcda
        -:    0:Runs:11
        -:    1:#include "velha.hpp"
        -:    2:#include <cmath>
        -:    3:
      217:    4:int verificar_jogo(jogoVelha jogo){
        -:    5:    /**
        -:    6:     * Percorre a matriz 3x3 para cada estado de jogo.
        -:    7:     * 0 vazio, 1 X, 2 O
        -:    8:    */
        -:    9:
      217:   10:    int count_x = 0, count_o = 0;
        -:   11:
      868:   12:    for(int i = 0; i < 3; i++) {
     2604:   13:        for (int j = 0; j < 3; j++){
     1953:   14:            if (jogo[i][j] == 1) count_x++;
     1210:   15:            else if (jogo[i][j] == 2) count_o++;
        -:   16:        }
        -:   17:    }
        -:   18:    //  ( " " ) (' ')
        -:   19:
        -:   20:    /**
        -:   21:     * Se um jogador inseriu O ou X em mais de 5 posições as regras foram violadas: retorna -2
        -:   22:    */
      217:   23:    if (count_x > 5 || count_o > 5) return -2;
        -:   24:
        -:   25:    /** 
        -:   26:     * A diferença entre o número de Xs e Os não pode ser maior que 1
        -:   27:     * O não pode ter mais peças que X (X começa a partida)
        -:   28:    */
      193:   29:    if (count_o > count_x || std::abs(count_x - count_o) > 1) return -2;
        -:   30:
        -:   31:
        -:   32:    /// Condicoes para ganhar
      160:   33:    int x_ganha = 0, o_ganha = 0;
        -:   34:
        -:   35:    /// Linhas 
      640:   36:    for (int i = 0; i < 3; i++){
      480:   37:        if (jogo[i][0] == 1 && jogo[i][1] == 1 && jogo[i][2] == 1) x_ganha++;
      466:   38:        else if (jogo[i][0] == 2 && jogo[i][1] == 2 && jogo[i][2] == 2) o_ganha++;
        -:   39:    }
        -:   40:
        -:   41:    /// Colunas
      640:   42:    for (int j = 0; j < 3; j++){
      480:   43:        if (jogo[0][j] == 1 && jogo[1][j] == 1 && jogo[2][j] == 1) x_ganha++;
      464:   44:        else if (jogo[0][j] == 2 && jogo[1][j] == 2 && jogo[2][j] == 2) o_ganha++;
        -:   45:    }
        -:   46:
        -:   47:    /// Diagonais
      160:   48:    if (jogo[0][0] == 1 && jogo[1][1] == 1 && jogo[2][2] == 1) x_ganha++;
      149:   49:    else if (jogo[0][0] == 2 && jogo[1][1] == 2 && jogo[2][2] == 2) o_ganha++;
      138:   50:    else if (jogo[2][0] == 1 && jogo[1][1] == 1 && jogo[0][2] == 1) x_ganha++;
      127:   51:    else if (jogo[2][0] == 2 && jogo[1][1] == 2 && jogo[0][2] == 2) o_ganha++;
        -:   52:
        -:   53:    /// Nao é possivei os dois ganharem
      160:   54:    if (x_ganha > 0 && o_ganha > 0) return -2;
        -:   55:
      152:   56:    if (x_ganha > 0) {
        -:   57:        /// X só pode vencer se ele tiver uma jogada a mais
       44:   58:        if (count_x == count_o + 1) return 1;
    #####:   59:        else return -2;
        -:   60:    }
        -:   61:
      108:   62:    if (o_ganha > 0) {
        -:   63:        /// O só pode vencer se tiver jogado <= número de vezes que X 
       44:   64:        if (count_o == count_x || count_o == count_x - 1) return 2;
    #####:   65:        else return -2;
        -:   66:    }
        -:   67:
        -:   68:    /// Jogo empatado
       64:   69:    if ((count_x + count_o) == 9) return 0;
        -:   70:
        -:   71:    /// Jogo em andamento
       33:   72:    return -1;
        -:   73:}
